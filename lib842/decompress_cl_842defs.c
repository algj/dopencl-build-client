const char *LIB842_CLDECOMPRESS_842DEFS_SOURCE =
"#ifndef LIB842_SRC_COMMON_842_H\n"
"#define LIB842_SRC_COMMON_842_H\n"
"\n"
"/* The 842 compressed format is made up of multiple blocks, each of\n"
" * which have the format:\n"
" *\n"
" * <template>[arg1][arg2][arg3][arg4]\n"
" *\n"
" * where there are between 0 and 4 template args, depending on the specific\n"
" * template operation.  For normal operations, each arg is either a specific\n"
" * number of data bytes to add to the output buffer, or an index pointing\n"
" * to a previously-written number of data bytes to copy to the output buffer.\n"
" *\n"
" * The template code is a 5-bit value.  This code indicates what to do with\n"
" * the following data.  Template codes from 0 to 0x19 should use the template\n"
" * table, the static \"decomp_ops\" table used in decompress.  For each template\n"
" * (table row), there are between 1 and 4 actions; each action corresponds to\n"
" * an arg following the template code bits.  Each action is either a \"data\"\n"
" * type action, or a \"index\" type action, and each action results in 2, 4, or 8\n"
" * bytes being written to the output buffer.  Each template (i.e. all actions\n"
" * in the table row) will add up to 8 bytes being written to the output buffer.\n"
" * Any row with less than 4 actions is padded with noop actions, indicated by\n"
" * N0 (for which there is no corresponding arg in the compressed data buffer).\n"
" *\n"
" * \"Data\" actions, indicated in the table by D2, D4, and D8, mean that the\n"
" * corresponding arg is 2, 4, or 8 bytes, respectively, in the compressed data\n"
" * buffer should be copied directly to the output buffer.\n"
" *\n"
" * \"Index\" actions, indicated in the table by I2, I4, and I8, mean the\n"
" * corresponding arg is an index parameter that points to, respectively, a 2,\n"
" * 4, or 8 byte value already in the output buffer, that should be copied to\n"
" * the end of the output buffer.  Essentially, the index points to a position\n"
" * in a ring buffer that contains the last N bytes of output buffer data.\n"
" * The number of bits for each index's arg are: 8 bits for I2, 9 bits for I4,\n"
" * and 8 bits for I8.  Since each index points to a 2, 4, or 8 byte section,\n"
" * this means that I2 can reference 512 bytes ((2^8 bits = 256) * 2 bytes), I4\n"
" * can reference 2048 bytes ((2^9 = 512) * 4 bytes), and I8 can reference 2048\n"
" * bytes ((2^8 = 256) * 8 bytes).  Think of it as a kind-of ring buffer for\n"
" * each of I2, I4, and I8 that are updated for each byte written to the output\n"
" * buffer.  In this implementation, the output buffer is directly used for each\n"
" * index; there is no additional memory required.  Note that the index is into\n"
" * a ring buffer, not a sliding window; for example, if there have been 260\n"
" * bytes written to the output buffer, an I2 index of 0 would index to byte 256\n"
" * in the output buffer, while an I2 index of 16 would index to byte 16 in the\n"
" * output buffer.\n"
" *\n"
" * There are also 3 special template codes; 0x1b for \"repeat\", 0x1c for\n"
" * \"zeros\", and 0x1e for \"end\".  The \"repeat\" operation is followed by a 6 bit\n"
" * arg N indicating how many times to repeat.  The last 8 bytes written to the\n"
" * output buffer are written again to the output buffer, N + 1 times.  The\n"
" * \"zeros\" operation, which has no arg bits, writes 8 zeros to the output\n"
" * buffer.  The \"end\" operation, which also has no arg bits, signals the end\n"
" * of the compressed data.  There may be some number of padding (don't care,\n"
" * but usually 0) bits after the \"end\" operation bits, to fill the buffer\n"
" * length to a specific byte multiple (usually a multiple of 8, 16, or 32\n"
" * bytes).\n"
" *\n"
" * This software implementation also uses one of the undefined template values,\n"
" * 0x1d as a special \"short data\" template code, to represent less than 8 bytes\n"
" * of uncompressed data.  It is followed by a 3 bit arg N indicating how many\n"
" * data bytes will follow, and then N bytes of data, which should be copied to\n"
" * the output buffer.  This allows the software 842 compressor to accept input\n"
" * buffers that are not an exact multiple of 8 bytes long.  However, those\n"
" * compressed buffers containing this sw-only template will be rejected by\n"
" * the 842 hardware decompressor, and must be decompressed with this software\n"
" * library.  The 842 software compression module includes a parameter to\n"
" * disable using this sw-only \"short data\" template, and instead simply\n"
" * reject any input buffer that is not a multiple of 8 bytes long.\n"
" *\n"
" * After all actions for each operation code are processed, another template\n"
" * code is in the next 5 bits.  The decompression ends once the \"end\" template\n"
" * code is detected.\n"
" */\n"
"\n"
"/* special templates */\n"
"#define OP_REPEAT	(0x1B)\n"
"#define OP_ZEROS	(0x1C)\n"
"#define OP_END		(0x1E)\n"
"\n"
"/* sw only template - this is not in the hw design; it's used only by this\n"
" * software compressor and decompressor, to allow input buffers that aren't\n"
" * a multiple of 8.\n"
" */\n"
"#define OP_SHORT_DATA	(0x1D)\n"
"\n"
"/* additional bits of each op param */\n"
"#define OP_BITS		(5)\n"
"#define REPEAT_BITS	(6)\n"
"#define SHORT_DATA_BITS	(3)\n"
"#define I2_BITS		(8)\n"
"#define I4_BITS		(9)\n"
"#define I8_BITS		(8)\n"
"#define CRC_BITS	(32)\n"
"\n"
"#define REPEAT_BITS_MAX		(0x3f)\n"
"#define SHORT_DATA_BITS_MAX	(0x7)\n"
"\n"
"/* Arbitrary values used to indicate action */\n"
"#define OP_ACTION	(0x70)\n"
"#define OP_ACTION_INDEX	(0x10)\n"
"#define OP_ACTION_DATA	(0x20)\n"
"#define OP_ACTION_NOOP	(0x40)\n"
"#define OP_AMOUNT	(0x0f)\n"
"#define OP_AMOUNT_0	(0x00)\n"
"#define OP_AMOUNT_2	(0x02)\n"
"#define OP_AMOUNT_4	(0x04)\n"
"#define OP_AMOUNT_8	(0x08)\n"
"\n"
"#define D2		(OP_ACTION_DATA  | OP_AMOUNT_2)\n"
"#define D4		(OP_ACTION_DATA  | OP_AMOUNT_4)\n"
"#define D8		(OP_ACTION_DATA  | OP_AMOUNT_8)\n"
"#define I2		(OP_ACTION_INDEX | OP_AMOUNT_2)\n"
"#define I4		(OP_ACTION_INDEX | OP_AMOUNT_4)\n"
"#define I8		(OP_ACTION_INDEX | OP_AMOUNT_8)\n"
"#define N0		(OP_ACTION_NOOP  | OP_AMOUNT_0)\n"
"\n"
"/* the max of the regular templates - not including the special templates */\n"
"#define OPS_MAX		(0x1a)\n"
"\n"
"/* Extended definitions - used by the optimized implementations */\n"
"#define D2_BITS 	(16)\n"
"#define D4_BITS 	(32)\n"
"#define D8_BITS 	(64)\n"
"#define N0_BITS		(0)\n"
"\n"
"/* Extended definitions - used by the optimized, branch-free implementations */\n"
"#define OP_DEC_NOOP  (0x00)\n"
"#define OP_DEC_DATA	 (0x00)\n"
"#define OP_DEC_INDEX (0x80)\n"
"\n"
"#define OP_DEC_N0	{(N0_BITS | OP_DEC_NOOP),  0}\n"
"#define OP_DEC_D2	{(D2_BITS | OP_DEC_DATA),  2}\n"
"#define OP_DEC_D4	{(D4_BITS | OP_DEC_DATA),  4}\n"
"#define OP_DEC_D8	{(D8_BITS | OP_DEC_DATA),  8}\n"
"#define OP_DEC_I2	{(I2_BITS | OP_DEC_INDEX), 2}\n"
"#define OP_DEC_I4	{(I4_BITS | OP_DEC_INDEX), 4}\n"
"#define OP_DEC_I8	{(I8_BITS | OP_DEC_INDEX), 8}\n"
"\n"
"\n"
"#endif // LIB842_SRC_COMMON_842_H\n"
""
;
